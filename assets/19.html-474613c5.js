const l=JSON.parse('{"key":"v-1e40b7ea","path":"/notes/java/19.html","title":"19 【多線程】","lang":"zh-TW","frontmatter":{},"headers":[{"level":2,"title":"1. 介紹","slug":"_1-介紹","link":"#_1-介紹","children":[]},{"level":2,"title":"2. 平行 與 並行","slug":"_2-平行-與-並行","link":"#_2-平行-與-並行","children":[]},{"level":2,"title":"3. 多線程的實現方式","slug":"_3-多線程的實現方式","link":"#_3-多線程的實現方式","children":[]},{"level":2,"title":"4. 常見成員方法","slug":"_4-常見成員方法","link":"#_4-常見成員方法","children":[]},{"level":2,"title":"5. 線程的生命週期","slug":"_5-線程的生命週期","link":"#_5-線程的生命週期","children":[]},{"level":2,"title":"6. 同步程式碼區域","slug":"_6-同步程式碼區域","link":"#_6-同步程式碼區域","children":[]},{"level":2,"title":"7. 同步方法","slug":"_7-同步方法","link":"#_7-同步方法","children":[]},{"level":2,"title":"8. lock鎖","slug":"_8-lock鎖","link":"#_8-lock鎖","children":[]},{"level":2,"title":"9. 死鎖","slug":"_9-死鎖","link":"#_9-死鎖","children":[]},{"level":2,"title":"10. 生產者 與 消費者(等待喚醒機制)","slug":"_10-生產者-與-消費者-等待喚醒機制","link":"#_10-生產者-與-消費者-等待喚醒機制","children":[{"level":3,"title":"1. 常見方法","slug":"_1-常見方法","link":"#_1-常見方法","children":[]},{"level":3,"title":"2. 範例","slug":"_2-範例","link":"#_2-範例","children":[]},{"level":3,"title":"3. 等待喚醒機制(阻塞對對列方式實現)","slug":"_3-等待喚醒機制-阻塞對對列方式實現","link":"#_3-等待喚醒機制-阻塞對對列方式實現","children":[]}]},{"level":2,"title":"11. 多線程的6種狀態","slug":"_11-多線程的6種狀態","link":"#_11-多線程的6種狀態","children":[]},{"level":2,"title":"12. 線程池","slug":"_12-線程池","link":"#_12-線程池","children":[{"level":3,"title":"1. 多線程的弊端","slug":"_1-多線程的弊端","link":"#_1-多線程的弊端","children":[]},{"level":3,"title":"2. 線程池主要核心原理","slug":"_2-線程池主要核心原理","link":"#_2-線程池主要核心原理","children":[]},{"level":3,"title":"3. 線程池的工具類","slug":"_3-線程池的工具類","link":"#_3-線程池的工具類","children":[]},{"level":3,"title":"4. 自定義線程池","slug":"_4-自定義線程池","link":"#_4-自定義線程池","children":[]}]},{"level":2,"title":"13. 最大並行數","slug":"_13-最大並行數","link":"#_13-最大並行數","children":[]},{"level":2,"title":"14. 線程池多大才合適","slug":"_14-線程池多大才合適","link":"#_14-線程池多大才合適","children":[]}],"git":{},"filePathRelative":"notes/java/19.md"}');export{l as data};
