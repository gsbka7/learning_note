import{_ as a,p as e,q as n,a1 as s}from"./framework-96b046e1.js";const p={},i=s(`<h1 id="_01-【-框架解決的問題-】" tabindex="-1"><a class="header-anchor" href="#_01-【-框架解決的問題-】" aria-hidden="true">#</a> 01 【 框架解決的問題 】</h1><h2 id="_1-三層架構" tabindex="-1"><a class="header-anchor" href="#_1-三層架構" aria-hidden="true">#</a> 1. 三層架構</h2><ol><li><p>表現層：接收前端發送的請求、對請求進行處理、並返回結果給前端</p></li><li><p>業務邏輯層：呼叫資料存取層，將資料庫中取得的資料，根據請求做邏輯處理(例如判斷user是否存在、再進行刪除)</p></li><li><p>資料存取層：訪問資料庫，對資料庫進行增刪改查等操作</p></li></ol><h4 id="關係" tabindex="-1"><a class="header-anchor" href="#關係" aria-hidden="true">#</a> 關係</h4><p>表現層呼叫業務邏輯層、業務邏輯層呼叫資料存取層</p><h4 id="優點" tabindex="-1"><a class="header-anchor" href="#優點" aria-hidden="true">#</a> 優點</h4><p>。 良好的共用性與擴充性</p><p>。 對修改關閉</p><p>。 後期維護成本低</p><p>。 有利於摽準化</p><h2 id="_2-內聚、耦合" tabindex="-1"><a class="header-anchor" href="#_2-內聚、耦合" aria-hidden="true">#</a> 2. 內聚、耦合</h2><p>。 內聚：各個模組內部的功能聯繫</p><p>。 耦合：每個層與模組之間的依賴，關聯程度</p><p>。 設計原則：高內聚低耦合</p><blockquote><p>。 模組內部的功能聯繫越緊密越好</p><p>。 盡可能地降低層與層或模組與模組間的依賴關聯</p><p>。 最好能夠做到解除耦合，層與層之間就沒有依賴了。即使某個層的程式碼發生改動，也不會影響其他層的程式碼。靈活性與擴展性會更佳</p></blockquote><h4 id="舉例" tabindex="-1"><a class="header-anchor" href="#舉例" aria-hidden="true">#</a> 舉例：</h4><blockquote><p>表現層(controller)使用呼叫業務邏輯層(service)：controller依賴了service的實體物件</p><p>業務邏輯層(service)呼叫資料存取層(dao)：service依賴了dao的實體物件</p></blockquote><h2 id="_2-opc開閉原則" tabindex="-1"><a class="header-anchor" href="#_2-opc開閉原則" aria-hidden="true">#</a> 2. OPC開閉原則</h2><p>。 對擴展開放</p><p>。 對修改關閉</p><h4 id="核心" tabindex="-1"><a class="header-anchor" href="#核心" aria-hidden="true">#</a> 核心</h4><p>擴展功能時，沒有修改以前的程式碼，就是符合原則</p><p>當修改了以前的程式碼，所有的程式都需要進行重新測試</p><h2 id="_3-dip原則-依賴反轉原則" tabindex="-1"><a class="header-anchor" href="#_3-dip原則-依賴反轉原則" aria-hidden="true">#</a> 3. DIP原則(依賴反轉原則)</h2><p>。 上不依賴下，符合依賴反轉原則</p><blockquote><p>違反依賴反轉原則：</p><p>表現層(controller)使用呼叫業務邏輯層(service)：controller依賴了service的實體物件</p><p>業務邏輯層(service)呼叫資料存取層(dao)：service依賴了dao的實體物件</p></blockquote><p>。 面向接口，不要面向具體</p><blockquote><p>在類中只有接口，沒有實現類</p></blockquote><p>。 降低耦合，提高擴展力</p><h2 id="_4-ioc控制反轉" tabindex="-1"><a class="header-anchor" href="#_4-ioc控制反轉" aria-hidden="true">#</a> 4. IoC控制反轉</h2><p>。 一種編寫程式的思想，解決程式違反了OPC和DIP原則的設計模式</p><p>。 降低耦合度，提高擴展力</p><p>。 物件建立的控制權由程式自身轉移到外部(容器)</p><blockquote><p>不用new的方式來維護物件的關係</p><p>new物件與物件之間的維護權利交由第三方容器管理</p></blockquote><p>。 IoC容器中建立、管理的物件、稱為bean</p><h3 id="_1-spring框架" tabindex="-1"><a class="header-anchor" href="#_1-spring框架" aria-hidden="true">#</a> 1. Spring框架</h3><p>。 實現了IoC控制反轉的思想</p><blockquote><p>幫助new實體化物件</p><p>幫助維護物件與物件之間的關係</p></blockquote><p>。 一個實現了IoC思想的容器</p><p>。 實現方式：依賴注入(DI)</p><blockquote><p>控制反轉是思想，依賴注入是思想的具體實現方式</p><p>包含了兩種方式：set注入、構造方法注入</p></blockquote><h3 id="_3-依賴注入-di" tabindex="-1"><a class="header-anchor" href="#_3-依賴注入-di" aria-hidden="true">#</a> 3. 依賴注入(DI)</h3><p>。 容器為應用程式提供執行時所依賴的資源</p><h4 id="實現方式" tabindex="-1"><a class="header-anchor" href="#實現方式" aria-hidden="true">#</a> 實現方式</h4><p>。 第一種：set注入(執行set方法給屬性賦值)</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>。 第二種：構造方法注入(執行構造方法給屬性賦值)</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">String</span> password<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>password <span class="token operator">=</span> password<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>。 依賴：A物件對B物件的關係</p><p>。 注入：一種資料傳遞行為，讓A物件與B物件產生關係</p><p>。 依賴注入：A物件對B物件之間的關係，依靠注入的手段來維持。注入包含set注入與構造方法注入</p><h2 id="_5-術語" tabindex="-1"><a class="header-anchor" href="#_5-術語" aria-hidden="true">#</a> 5. 術語</h2><p>OPC：關閉原則(開發原則)</p><p>DIP：依賴倒置原則(開發原則)</p><p>IoC：控制反轉(一種思想，新型的設計模式)</p><p>DI：注入依賴(控制反轉思想的具體實現方式)</p>`,56),o=[i];function t(c,r){return e(),n("div",null,o)}const l=a(p,[["render",t],["__file","01.html.vue"]]);export{l as default};
